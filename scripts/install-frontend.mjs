#!/usr/bin/env node
import { spawnSync } from "node:child_process";
import { fileURLToPath } from "node:url";
import { dirname, resolve } from "node:path";
import { existsSync, readFileSync, rmSync, writeFileSync } from "node:fs";

const THIS_FILE = fileURLToPath(import.meta.url);
const ROOT_DIR = dirname(THIS_FILE);
const PROJECT_ROOT = resolve(ROOT_DIR, "..");
const FRONTEND_DIR = resolve(PROJECT_ROOT, "apps", "dashboard-web");
const NPMRC_PATH = resolve(FRONTEND_DIR, ".npmrc");

const env = { ...process.env };
const npmExecutable = process.platform === "win32" ? "cmd.exe" : "npm";

const registryUrl = env.NPM_REGISTRY_URL?.trim() || "https://registry.npmjs.org/";
const disableProxy = env.NPM_REGISTRY_DISABLE_PROXY === "true";
const noProxy = env.NPM_REGISTRY_NO_PROXY?.trim();
const caFile = env.NPM_REGISTRY_CA_FILE?.trim() || env.SSL_CERT_FILE?.trim() || env.NODE_EXTRA_CA_CERTS?.trim();
const strictSsl = env.NPM_REGISTRY_STRICT_SSL?.trim();
const alwaysAuth = env.NPM_REGISTRY_ALWAYS_AUTH === "true";
const authToken = env.NPM_REGISTRY_TOKEN?.trim();

if (disableProxy) {
  for (const key of Object.keys(env)) {
    if (key.toLowerCase().includes("proxy")) {
      delete env[key];
    }
  }
}

env.npm_config_registry = registryUrl;
if (noProxy) {
  env.npm_config_noproxy = noProxy;
}
if (caFile) {
  env.npm_config_cafile = caFile;
}
if (strictSsl === "false") {
  env.npm_config_strict_ssl = "false";
}
if (alwaysAuth || authToken) {
  env.npm_config_always_auth = "true";
}
if (authToken) {
  const registryHost = new URL(registryUrl).host.replace(/\/$/, "");
  env[`npm_config_//${registryHost}/:_authToken`] = authToken;
}

const header = `; This file is generated by scripts/install-frontend.mjs\nregistry=${registryUrl}\n`;
const npmrcLines = [header];
if (noProxy) {
  npmrcLines.push(`noproxy=${noProxy}\n`);
}
if (caFile) {
  npmrcLines.push(`cafile=${caFile}\n`);
}
if (strictSsl === "false") {
  npmrcLines.push("strict-ssl=false\n");
}
if (alwaysAuth || authToken) {
  npmrcLines.push("always-auth=true\n");
}
if (authToken) {
  const registryHost = new URL(registryUrl).host.replace(/\/$/, "");
  npmrcLines.push(`//${registryHost}/:_authToken=${authToken}\n`);
}
const npmrcExisted = existsSync(NPMRC_PATH);
let originalNpmrc = null;
if (npmrcExisted) {
  try {
    originalNpmrc = readFileSync(NPMRC_PATH, "utf8");
  } catch (error) {
    console.warn(`[install-frontend] Unable to read existing ${NPMRC_PATH}:`, error.message ?? error);
  }
}

writeFileSync(NPMRC_PATH, npmrcLines.join(""));

function runNpm(args) {
  const finalArgs =
    process.platform === "win32" ? ["/d", "/s", "/c", "npm", ...args] : args;
  const result = spawnSync(npmExecutable, finalArgs, {
    cwd: PROJECT_ROOT,
    env,
    encoding: "utf8",
  });
  if (result.stdout) {
    process.stdout.write(result.stdout);
  }
  if (result.stderr) {
    process.stderr.write(result.stderr);
  }
  return result;
}

function installWith(commandArgs, label) {
  console.log(`\n[install-frontend] Running ${label}...`);
  const result = runNpm(["--prefix", FRONTEND_DIR, ...commandArgs]);
  const combinedOutput = `${result.stdout ?? ""}${result.stderr ?? ""}`;
  const exitCode =
    typeof result.status === "number"
      ? result.status
      : result.error && typeof result.error.code === "number"
        ? result.error.code
        : 1;

  if (result.error) {
    console.error(`[install-frontend] ${label} spawn failed: ${result.error.message}`);
  }

  if (exitCode === 0) {
    return { ok: true, output: "" };
  }

  const isForbidden = /E403|403 Forbidden/.test(combinedOutput);
  if (isForbidden) {
    console.error("[install-frontend] Received 403 from registry. Check NPM_REGISTRY_URL and credentials.");
  }

  return {
    ok: false,
    output: combinedOutput,
    exitCode,
    error: result.error,
  };
}

let installSucceeded = false;
let exitCode = 1;
const persistNpmrc = env.NPM_REGISTRY_PERSIST_NPMRC === "true";

try {
  const primary = installWith(["ci"], "npm ci");
  if (primary.ok) {
    installSucceeded = true;
    exitCode = 0;
  } else {
    const fallback = installWith(["install", "--prefer-offline", "--no-audit", "--progress=false"], "npm install fallback");
    installSucceeded = fallback.ok;
    exitCode = installSucceeded ? 0 : fallback.exitCode ?? 1;
    if (!installSucceeded) {
      console.error("[install-frontend] Failed to install frontend dependencies.");
    }
  }
} finally {
  if (!persistNpmrc) {
    if (npmrcExisted) {
      if (originalNpmrc !== null) {
        try {
          writeFileSync(NPMRC_PATH, originalNpmrc);
        } catch (error) {
          console.warn(
            `[install-frontend] Unable to restore previous ${NPMRC_PATH}:`,
            error.message ?? error,
          );
        }
      }
    } else {
      try {
        rmSync(NPMRC_PATH);
      } catch (error) {
        if (error?.code !== "ENOENT") {
          console.warn(`[install-frontend] Unable to clean up ${NPMRC_PATH}:`, error.message ?? error);
        }
      }
    }
  }
  process.exit(installSucceeded ? 0 : exitCode);
}
